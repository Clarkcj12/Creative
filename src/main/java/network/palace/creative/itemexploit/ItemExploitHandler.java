package network.palace.creative.itemexploit;

import com.comphenix.protocol.utility.MinecraftReflection;
import com.comphenix.protocol.wrappers.nbt.NbtCompound;
import com.comphenix.protocol.wrappers.nbt.NbtFactory;
import com.comphenix.protocol.wrappers.nbt.NbtList;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Multimap;
import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import java.io.File;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.UUID;
import java.util.function.Predicate;
import java.util.logging.Logger;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import network.palace.core.Core;
import network.palace.core.player.CPlayer;
import network.palace.core.player.Rank;
import network.palace.core.utils.ItemUtil;
import network.palace.creative.Creative;
import network.palace.creative.inventory.Menu;
import network.palace.creative.inventory.MenuButton;
import network.palace.creative.packets.PacketID.Dashboard;
import network.palace.creative.utils.MenuUtil;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Material;
import org.bukkit.OfflinePlayer;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.enchantments.Enchantment;
import org.bukkit.entity.EntityType;
import org.bukkit.entity.Item;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.entity.EntityPickupItemEvent;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.event.inventory.InventoryCreativeEvent;
import org.bukkit.event.player.PlayerDropItemEvent;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.event.player.PlayerJoinEvent;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.PlayerInventory;
import org.bukkit.inventory.meta.FireworkMeta;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.inventory.meta.PotionMeta;

public class ItemExploitHandler implements Listener {

    private final Multimap<Material, Short> blockedItems = ArrayListMultimap.create();
    private final Predicate<ItemStack> airCheck = itemStack -> itemStack.getType() != Material.AIR;
    public final Predicate<ItemStack> headCheck = itemStack -> {
        if (itemStack.getType() == Material.SKULL_ITEM) {
            switch (itemStack.getDurability()) {
                case 0:
                case 1:
                case 2:
                case 4:
                case 5:
                    return false;
                case 3:
                    NbtCompound tag = getTag(itemStack);
                    if (tag.getKeys().size() == 0) {
                        return false;
                    }
                    else {
                        return Creative.getInstance().getHeadUtil().getCategories().values().stream().flatMap(List::stream).map(this::getTexture).noneMatch(head -> getTexture(itemStack).filter(stack -> head.filter(h -> h.equals(stack)).isPresent()).isPresent());
                    }
            }

            return true;
        }

        return false;
    };
    public final Predicate<ItemStack> potionCheck = itemStack -> {
        Material material = itemStack.getType();
        if (material == Material.POTION || material == Material.LINGERING_POTION || material == Material.SPLASH_POTION) {
            if (itemStack.hasItemMeta()) {
                PotionMeta potionMeta = (PotionMeta) itemStack.getItemMeta();
                return potionMeta.hasCustomEffects();
            }
        }

        return false;
    };
    public final Predicate<ItemStack> enchantmentCheck = itemStack -> {
        if (itemStack.hasItemMeta()) {
            ItemMeta itemMeta = itemStack.getItemMeta();
            if (itemMeta.hasEnchants()) {
                return Stream.of(Enchantment.values()).filter(itemMeta::hasEnchant).filter(itemMeta::hasConflictingEnchant).anyMatch(enchant -> itemMeta.getEnchantLevel(enchant) > enchant.getMaxLevel());
            }
        }

        return false;
    };
    public final Predicate<ItemStack> bannedItemCheck = itemStack -> blockedItems.containsKey(itemStack.getType()) && blockedItems.get(itemStack.getType()).contains(itemStack.getDurability());
    public final Predicate<ItemStack> durabilityCheck = itemStack -> {
        switch (itemStack.getType()) {
            case BOW:
            case CARROT_STICK:
            case CHAINMAIL_BOOTS:
            case CHAINMAIL_CHESTPLATE:
            case CHAINMAIL_HELMET:
            case CHAINMAIL_LEGGINGS:
            case DIAMOND_AXE:
            case DIAMOND_BOOTS:
            case DIAMOND_CHESTPLATE:
            case DIAMOND_HELMET:
            case DIAMOND_HOE:
            case DIAMOND_LEGGINGS:
            case DIAMOND_PICKAXE:
            case DIAMOND_SPADE:
            case DIAMOND_SWORD:
            case ELYTRA:
            case GOLD_AXE:
            case GOLD_BOOTS:
            case GOLD_CHESTPLATE:
            case GOLD_HELMET:
            case GOLD_HOE:
            case GOLD_LEGGINGS:
            case GOLD_PICKAXE:
            case GOLD_SPADE:
            case GOLD_SWORD:
            case FISHING_ROD:
            case IRON_AXE:
            case IRON_BOOTS:
            case IRON_CHESTPLATE:
            case IRON_HOE:
            case IRON_LEGGINGS:
            case IRON_PICKAXE:
            case IRON_SPADE:
            case IRON_SWORD:
            case LEATHER_BOOTS:
            case LEATHER_CHESTPLATE:
            case LEATHER_HELMET:
            case LEATHER_LEGGINGS:
            case SHIELD:
            case STONE_AXE:
            case STONE_HOE:
            case STONE_PICKAXE:
            case STONE_SPADE:
            case STONE_SWORD:
            case WOOD_AXE:
            case WOOD_HOE:
            case WOOD_PICKAXE:
            case WOOD_SWORD:
                return itemStack.getDurability() > 0;
            default:
                return false;
        }
    };
    public final Predicate<ItemStack> fireworkCheck = itemStack -> {
        if (itemStack.getType() == Material.FIREWORK && itemStack.hasItemMeta()) {
            FireworkMeta meta = (FireworkMeta) itemStack.getItemMeta();
            return meta.getEffectsSize() > 5;
        }

        return false;
    };
    public final Predicate<ItemStack> attributeCheck = itemStack -> getTag(itemStack).containsKey("AttributeModifiers");
    private final List<String> bannedJsonTextComponentKeys = Arrays.asList("translate", "with", "score", "selector", "keybind", "color", "bold", "italic", "underlined", "strikethrough", "obfuscated", "insertion", "clickEvent", "hoverEvent");
    public final Predicate<ItemStack> bookCheck = itemStack -> {
        NbtCompound tag = getTag(itemStack);
        if (tag.containsKey("pages")) {
            NbtList<String> pages = tag.getList("pages");
            if (pages.size() > 0) {
                return pages.asCollection().stream().map(page -> new Gson().fromJson(page.getValue(), JsonObject.class)).filter(JsonElement::isJsonObject).map(JsonElement::getAsJsonObject).anyMatch(json -> bannedJsonTextComponentKeys.stream().anyMatch(json::has));
            }
        }

        return false;
    };
    public final Predicate<ItemStack> loreCheck = itemStack -> itemStack.hasItemMeta() && itemStack.getItemMeta().hasLore();
    public final Predicate<ItemStack> itemNameCheck = itemStack -> {
        if (itemStack.hasItemMeta()) {
            ItemMeta itemMeta = itemStack.getItemMeta();
            if (itemMeta.hasDisplayName()) {
                return Stream.of(ChatColor.values()).anyMatch(color -> itemMeta.getDisplayName().contains(color.toString()));
                /*NbtCompound tag = getTag(itemStack);
                if (tag.containsKey("display")) {
                    NbtCompound display = tag.getCompound("display");
                    if (display.containsKey("name")) {
                        return StreamSupport.stream(new Gson().fromJson(display.getString("name"), JsonArray.class).spliterator(), false).filter(JsonElement::isJsonObject).map(JsonElement::getAsJsonObject).anyMatch(json -> bannedJsonTextComponentKeys.stream().anyMatch(json::has));
                    }
                }*/
            }
        }

        return false;
    };
    private final Predicate<ItemStack> creativeMenuCheck = itemStack -> {
        if (itemStack.getType() == Material.NETHER_STAR && itemStack.hasItemMeta()) {
            ItemMeta itemMeta = itemStack.getItemMeta();
            return !(itemMeta.hasDisplayName() && itemMeta.getDisplayName().contains("Creative Menu") && itemMeta.hasEnchants());
        }

        return true;
    };
    private final List<CaughtUserData> users = new ArrayList<>();
    private final List<UUID> antiWarningSpam = new ArrayList<>();

    public ItemExploitHandler() {
        Logger logger = Creative.getInstance().getLogger();
        try {
            loadBlockedItems();
        }
        catch (IOException e) {
            logger.warning("An error occurred while trying to create/read banned_items.yml");
        }

        try {
            loadCaughtItems();
        }
        catch (IOException e) {
            logger.warning("An error occurred while trying to create/read caught_items.yml");
        }
    }

    private Optional<String> getTexture(ItemStack itemStack) {
        NbtCompound tag = getTag(itemStack);
        if (!tag.containsKey("SkullOwner")) {
            return Optional.empty();
        }

        NbtCompound skullOwner = tag.getCompound("SkullOwner");
        if (!skullOwner.containsKey("Properties")) {
            return Optional.empty();
        }

        NbtCompound properties = skullOwner.getCompound("Properties");
        if (!properties.containsKey("textures")) {
            return Optional.empty();
        }

        List<NbtCompound> textures = properties.getList("textures").asCollection().stream().filter(NbtCompound.class::isInstance).map(NbtCompound.class::cast).collect(Collectors.toList());
        if (textures.isEmpty()) {
            return Optional.empty();
        }

        NbtCompound value = textures.get(0);
        return Optional.ofNullable(value.getString("Value"));
    }

    public Optional<CaughtUserData> getData(UUID uuid) {
        return users.stream().filter(data -> data.getUuid().equals(uuid)).findFirst();
    }

    public void loadCaughtItems() throws IOException {
        users.clear();
        File caughtItemsFile = new File(Creative.getInstance().getDataFolder(), "caught_items.yml");
        if (!caughtItemsFile.exists()) {
            caughtItemsFile.getParentFile().mkdirs();
            caughtItemsFile.createNewFile();
        }

        YamlConfiguration yml = YamlConfiguration.loadConfiguration(caughtItemsFile);
        yml.getKeys(false).forEach(key -> {
            UUID uuid = UUID.fromString(key);
            List<CaughtItemData> itemData = new ArrayList<>();
            yml.getMapList(key).forEach(bannedItem -> {
                YamlConfiguration temp = new YamlConfiguration();
                bannedItem.forEach((k, v) -> temp.set(k.toString(), v));
                boolean handled = temp.getBoolean("handled");
                ItemStack item = temp.getItemStack("item");
                long timestamp = temp.getLong("time");
                itemData.add(new CaughtItemData(handled, item, timestamp));
            });
            CaughtUserData userData = new CaughtUserData(itemData, uuid);
            users.add(userData);
        });
    }

    public void saveCaughtItems() {
        YamlConfiguration yml = new YamlConfiguration();
        users.forEach(data -> yml.set(data.getUuid().toString(), data.getData().stream().map(cid -> {
            YamlConfiguration item = new YamlConfiguration();
            item.set("handled", cid.isHandled());
            item.set("item", cid.getItem());
            item.set("time", cid.getTimestamp());
            return item;
        }).collect(Collectors.toList())));

        try {
            File bannedItemsFile = new File(Creative.getInstance().getDataFolder(), "caught_items.yml");
            if (!bannedItemsFile.exists()) {
                bannedItemsFile.getParentFile().mkdirs();
                bannedItemsFile.createNewFile();
            }

            yml.save(bannedItemsFile);
        }
        catch (IOException e) {
            Creative.getInstance().getLogger().warning("An error occurred while trying to save caught_items.yml");
        }
    }

    public void loadBlockedItems() throws IOException {
        blockedItems.clear();
        File bannedItemsFile = new File(Creative.getInstance().getDataFolder(), "banned_items.yml");
        if (!bannedItemsFile.exists()) {
            bannedItemsFile.getParentFile().mkdirs();
            bannedItemsFile.createNewFile();
        }

        Logger logger = Creative.getInstance().getLogger();
        YamlConfiguration yml = YamlConfiguration.loadConfiguration(bannedItemsFile);
        yml.getKeys(false).forEach(key -> yml.getShortList(key).forEach(dmg -> {
            Material material = Material.getMaterial(key);
            if (material == null) {
                logger.warning("Material ID of " + key + " does not exist.");
            }

            blockedItems.put(material, dmg);
        }));
    }

    private void handle(Player player, List<ItemStack> items, Runnable action) {
        List<ItemStack> caughtItems = items.stream().filter(Objects::nonNull).filter(airCheck.and(creativeMenuCheck.and(enchantmentCheck.or(durabilityCheck.or(attributeCheck.or(bookCheck.or(loreCheck.or(bannedItemCheck.or(headCheck.or(potionCheck.or(itemNameCheck.or(fireworkCheck)))))))))))).collect(Collectors.toList());
        if (caughtItems.isEmpty()) {
            return;
        }

        action.run();
        player.updateInventory();
        Optional<CaughtUserData> dataOptional = this.users.stream().filter(data -> data.getUuid().equals(player.getUniqueId())).findFirst();
        if (dataOptional.isPresent()) {
            caughtItems.forEach(itemStack -> dataOptional.get().caughtItem(itemStack));
        }
        else {
            this.users.add(new CaughtUserData(caughtItems.stream().map(item -> new CaughtItemData(false, item, System.currentTimeMillis())).collect(Collectors.toList()), player.getUniqueId()));
        }

        if (antiWarningSpam.contains(player.getUniqueId())) {
            return;
        }

        Core.getPlayerManager().getOnlinePlayers().stream().filter(cPlayer -> cPlayer.getRank().getRankId() >= Rank.SRMOD.getRankId()).map(CPlayer::getBukkitPlayer).forEach(staff -> {
            antiWarningSpam.add(player.getUniqueId());
            Bukkit.getScheduler().runTaskLater(Creative.getInstance(), () -> antiWarningSpam.remove(player.getUniqueId()), 100);
            staff.sendMessage(ChatColor.AQUA + player.getName() + ChatColor.RED + " attempted to spawn/use a hacked/prohibited item!");
        });
    }

    @EventHandler
    public void onJoin(PlayerJoinEvent event) {
        Bukkit.getScheduler().scheduleSyncDelayedTask(Creative.getInstance(), () -> {
            Player player = event.getPlayer();
            CPlayer cPlayer = Core.getPlayerManager().getPlayer(player);
            if (cPlayer == null) {
                return;
            }

            if (cPlayer.getRank().getRankId() >= Rank.SRMOD.getRankId() && users.stream().map(CaughtUserData::getData).flatMap(List::stream).anyMatch(itemData -> !itemData.isHandled())) {
                player.sendMessage(ChatColor.AQUA + "There are pending banned/hacked item cases.");
            }
        });
    }

    @EventHandler
    public void onItemUse(PlayerInteractEvent event) {
        Player player = event.getPlayer();
        CPlayer cPlayer = Core.getPlayerManager().getPlayer(player);
        if (cPlayer == null || cPlayer.getRank().getRankId() >= Rank.TRAINEE.getRankId()) {
            return;
        }

        PlayerInventory inventory = player.getInventory();
        handle(player, Arrays.asList(inventory.getItemInMainHand(), inventory.getItemInOffHand()), () -> {
            inventory.setItemInMainHand(null);
            inventory.setItemInOffHand(null);
        });
    }

    @EventHandler
    public void onItemDrop(PlayerDropItemEvent event) {
        Player player = event.getPlayer();
        CPlayer cPlayer = Core.getPlayerManager().getPlayer(player);
        if (cPlayer == null || cPlayer.getRank().getRankId() >= Rank.TRAINEE.getRankId()) {
            return;
        }

        Item itemEntity = event.getItemDrop();
        handle(player, Collections.singletonList(itemEntity.getItemStack()), itemEntity::remove);
    }

    @EventHandler
    public void onItemPickup(EntityPickupItemEvent event) {
        if (event.getEntity().getType() != EntityType.PLAYER) {
            return;
        }

        Player player = (Player) event.getEntity();
        CPlayer cPlayer = Core.getPlayerManager().getPlayer(player);
        if (cPlayer == null || cPlayer.getRank().getRankId() >= Rank.TRAINEE.getRankId()) {
            return;
        }

        Item itemEntity = event.getItem();
        handle(player, Collections.singletonList(itemEntity.getItemStack()), () -> {
            Bukkit.getScheduler().scheduleSyncDelayedTask(Creative.getInstance(), itemEntity::remove);
            event.setCancelled(true);
        });
    }

    //PlotSquared error occurs w/o this
    @EventHandler(priority = EventPriority.HIGHEST)
    public void onCreativeInventoryClick(InventoryCreativeEvent event) {
        Player player = (Player) event.getWhoClicked();
        CPlayer cPlayer = Core.getPlayerManager().getPlayer(player);
        if (cPlayer == null || cPlayer.getRank().getRankId() >= Rank.TRAINEE.getRankId()) {
            return;
        }

        handle(player, Arrays.asList(event.getCurrentItem(), event.getCursor()), () -> {
            event.setCurrentItem(null);
            event.setCursor(null);
        });
    }

    private NbtCompound getTag(ItemStack itemStack) {
        return NbtFactory.fromNMSCompound(NbtFactory.fromItemTag(MinecraftReflection.getBukkitItemStack(itemStack)).getHandle());
    }

    public void viewPlayer(Player player, CaughtUserData userData, OfflinePlayer offlinePlayer, int page) {
        List<MenuButton> buttons = new ArrayList<>();
        List<CaughtItemData> caughtItems = userData.getData();
        for (int x = 0; x < 45; x++) {
            try {
                CaughtItemData itemData = caughtItems.get(x + (page - 1) * 45);
                ItemStack itemStack = itemData.getItem();
                buttons.add(new MenuButton(x, parseItem(itemStack, itemData), ImmutableMap.of(ClickType.LEFT, p -> {
                    p.getInventory().addItem(itemStack);
                    p.closeInventory();
                }, ClickType.RIGHT, p -> manageItem(p, userData, itemData, offlinePlayer))));
            }
            catch (IndexOutOfBoundsException ignored) {

            }
        }

        MenuUtil menuUtil = Creative.getInstance().getMenuUtil();
        if (page - 1 > 0) {
            buttons.add(new MenuButton(45, menuUtil.last, ImmutableMap.of(ClickType.LEFT, p -> viewPlayer(p, userData, offlinePlayer, page - 1))));
        }

        buttons.add(new MenuButton(49, menuUtil.back, ImmutableMap.of(ClickType.LEFT, Player::closeInventory)));
        if (page <= new Double(Math.ceil(caughtItems.size() / 45D)).intValue()) {
            buttons.add(new MenuButton(53, menuUtil.next, ImmutableMap.of(ClickType.LEFT, p -> viewPlayer(p, userData, offlinePlayer, page + 1))));
        }

        new Menu(Bukkit.createInventory(player, 54, ChatColor.RED + offlinePlayer.getName() + "'s Caught Items"), player, buttons);
    }

    private void manageItem(Player player, CaughtUserData userData, CaughtItemData itemData, OfflinePlayer offlinePlayer) {
        String reason = " Possession of banned/hacked items and/or hacked/modded client.";
        List<MenuButton> buttons = new ArrayList<>();
        buttons.add(new MenuButton(0, ItemUtil.create(Material.WATCH, ChatColor.GREEN + "Caught at " + new SimpleDateFormat("MM/dd/yyyy HH:mm:ss").format(new Date(itemData.getTimestamp()))), ImmutableMap.of()));
        buttons.add(new MenuButton(1, ItemUtil.create(Material.BARRIER, ChatColor.RED + "Delete.", Arrays.asList(ChatColor.GOLD + "Report this to the devs before doing this.")), ImmutableMap.of(ClickType.LEFT, p -> {
            userData.getData().remove(itemData);
            viewPlayer(player, userData, offlinePlayer, 1);
        })));
        buttons.add(new MenuButton(2, ItemUtil.create(Material.STONE_SWORD, ChatColor.RED + "Warn this player."), ImmutableMap.of(ClickType.LEFT, p -> {
            punish(p, "/warn " + offlinePlayer.getName() + reason);
            itemData.setHandled(true);
            player.sendMessage(ChatColor.GREEN + "The status of this item has been automatically changed from " + ChatColor.YELLOW + "Pending" + ChatColor.GREEN + " to " + ChatColor.YELLOW + "Complete" + ChatColor.GREEN + ".");
            player.closeInventory();
        })));
        buttons.add(new MenuButton(3, ItemUtil.create(Material.IRON_SWORD, ChatColor.RED + "Kick this player."), ImmutableMap.of(ClickType.LEFT, p -> {
            punish(p, "/kick " + offlinePlayer.getName() + reason);
            itemData.setHandled(true);
            player.sendMessage(ChatColor.GREEN + "The status of this item has been automatically changed from " + ChatColor.YELLOW + "Pending" + ChatColor.GREEN + " to " + ChatColor.YELLOW + "Complete" + ChatColor.GREEN + ".");
            player.closeInventory();
        })));
        buttons.add(new MenuButton(4, ItemUtil.create(Material.DIAMOND_SWORD, ChatColor.RED + "Temporarily Ban this player for 3 days."), ImmutableMap.of(ClickType.LEFT, p -> {
            punish(p, "/tempban " + offlinePlayer.getName() + " 3d" + reason);
            itemData.setHandled(true);
            player.sendMessage(ChatColor.GREEN + "The status of this item has been automatically changed from " + ChatColor.YELLOW + "Pending" + ChatColor.GREEN + " to " + ChatColor.YELLOW + "Complete" + ChatColor.GREEN + ".");
            player.closeInventory();
        })));
        buttons.add(new MenuButton(5, ItemUtil.create(Material.DIAMOND_SWORD, ChatColor.RED + "Temporarily Ban this player for 5 days."), ImmutableMap.of(ClickType.LEFT, p -> {
            punish(p, "/tempban " + offlinePlayer.getName() + " 5d" + reason);
            itemData.setHandled(true);
            player.sendMessage(ChatColor.GREEN + "The status of this item has been automatically changed from " + ChatColor.YELLOW + "Pending" + ChatColor.GREEN + " to " + ChatColor.YELLOW + "Complete" + ChatColor.GREEN + ".");
            player.closeInventory();
        })));
        buttons.add(new MenuButton(6, ItemUtil.create(Material.EMERALD, ChatColor.GREEN + "Status: " + ChatColor.YELLOW + (itemData.isHandled() ? "Complete" : "Pending")), ImmutableMap.of(ClickType.LEFT, p -> {
            itemData.setHandled(!itemData.isHandled());
            player.closeInventory();
        })));
        buttons.add(new MenuButton(8, Creative.getInstance().getMenuUtil().back, ImmutableMap.of(ClickType.LEFT, p -> viewPlayer(p, userData, offlinePlayer, 1))));
        new Menu(Bukkit.createInventory(player, 9, ChatColor.RED + "Manage This Item"), player, buttons);
    }

    private void punish(Player player, String command) {
        JsonObject jsonObject = new JsonObject();
        jsonObject.addProperty("id", Dashboard.PLAYERCHAT.getID());
        jsonObject.addProperty("uuid", player.getUniqueId().toString());
        jsonObject.addProperty("message", command);
        Core.getDashboardConnection().send(jsonObject.toString());
    }

    private List<String> parseLore(boolean handled, ItemStack itemStack) {
        ItemExploitHandler iel = Creative.getInstance().getItemExploitHandler();
        List<String> lore = new ArrayList<>();
        lore.add(ChatColor.GREEN + "LEFT-CLICK " + ChatColor.YELLOW + " to spawn this item for closer inspection.");
        lore.add(ChatColor.GREEN + "RIGHT-CLICK " + ChatColor.YELLOW + " to manage this item.");
        lore.add(ChatColor.LIGHT_PURPLE + "Status: " + (handled ? "Complete" : "Pending"));
        lore.add(ChatColor.GREEN + "Violations:");
        if (iel.bannedItemCheck.test(itemStack)) {
            lore.add(ChatColor.GREEN + "- Banned Block/Item");
        }

        if (iel.headCheck.test(itemStack)) {
            lore.add(ChatColor.GREEN + "- Non-Head Shop Head");
        }

        if (iel.potionCheck.test(itemStack)) {
            lore.add(ChatColor.GREEN + "- Custom Potion Effects");
        }

        if (iel.enchantmentCheck.test(itemStack)) {
            lore.add(ChatColor.GREEN + "- Invalid Enchantments");
        }

        if (iel.durabilityCheck.test(itemStack)) {
            lore.add(ChatColor.GREEN + "- Armor/Tool/Weapon Damage/Durability Not 0");
        }

        if (iel.fireworkCheck.test(itemStack)) {
            lore.add(ChatColor.GREEN + "- Too Many Firework Effects");
        }

        if (iel.attributeCheck.test(itemStack)) {
            lore.add(ChatColor.GREEN + "- Contains Attribute Modifiers");
        }

        if (iel.bookCheck.test(itemStack)) {
            lore.add(ChatColor.GREEN + "- Book Contents Not Plain Text");
        }

        if (iel.loreCheck.test(itemStack)) {
            lore.add(ChatColor.GREEN + "- Contains Lore");
        }

        if (iel.itemNameCheck.test(itemStack)) {
            lore.add(ChatColor.GREEN + "- Custom Item Name Not Plain Text");
        }

        return lore;
    }

    private ItemStack parseItem(ItemStack caughtItem, CaughtItemData itemData) {
        ItemStack itemStack = caughtItem.clone();
        ItemMeta itemMeta = itemStack.getItemMeta();
        itemMeta.setDisplayName(ChatColor.GREEN + "Caught at " + new SimpleDateFormat("MM/dd/yyyy HH:mm:ss").format(new Date(itemData.getTimestamp())));
        itemMeta.setLore(parseLore(itemData.isHandled(), caughtItem));
        itemStack.setItemMeta(itemMeta);
        return itemStack;
    }
}
