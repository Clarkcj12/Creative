package network.palace.creative.itemexploit;

import com.comphenix.protocol.utility.MinecraftReflection;
import com.comphenix.protocol.wrappers.nbt.NbtCompound;
import com.comphenix.protocol.wrappers.nbt.NbtFactory;
import com.comphenix.protocol.wrappers.nbt.NbtList;
import com.google.common.collect.ImmutableMap;
import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import network.palace.core.Core;
import network.palace.core.menu.Menu;
import network.palace.core.menu.MenuButton;
import network.palace.core.message.FormattedMessage;
import network.palace.core.player.CPlayer;
import network.palace.core.player.Rank;
import network.palace.core.utils.ItemUtil;
import network.palace.creative.Creative;
import network.palace.creative.utils.MenuUtil;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Material;
import org.bukkit.OfflinePlayer;
import org.bukkit.block.ShulkerBox;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.enchantments.Enchantment;
import org.bukkit.entity.EntityType;
import org.bukkit.entity.Item;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.entity.EntityPickupItemEvent;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.event.inventory.InventoryCreativeEvent;
import org.bukkit.event.player.PlayerDropItemEvent;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.event.player.PlayerJoinEvent;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.PlayerInventory;
import org.bukkit.inventory.meta.*;

import java.io.File;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.function.Predicate;
import java.util.logging.Logger;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

public class ItemExploitHandler implements Listener {

    private final List<Material> blockedItems = new ArrayList<>();
    private final Predicate<ItemStack> airCheck = itemStack -> itemStack.getType().equals(Material.AIR);
    private final Predicate<ItemStack> headCheck = itemStack -> {
        if (itemStack.getType() == Material.PLAYER_HEAD) {
            if (itemStack.hasItemMeta()) {
                NbtCompound tag = getTag(itemStack);
                if (tag.getKeys().size() > 0) {
                    return Creative.getInstance().getHeadUtil().getCategories().values().stream().flatMap(List::stream).map(this::getTexture).noneMatch(head -> getTexture(itemStack).filter(stack -> head.filter(h -> h.equals(stack)).isPresent()).isPresent());
                }
            }
        }

        return false;
    };
    private final Predicate<ItemStack> potionCheck = itemStack -> {
        Material material = itemStack.getType();
        if (material == Material.POTION || material == Material.LINGERING_POTION || material == Material.SPLASH_POTION) {
            if (itemStack.hasItemMeta()) {
                return ((PotionMeta) itemStack.getItemMeta()).hasCustomEffects();
            }
        }

        return false;
    };
    private final Predicate<ItemStack> enchantmentCheck = itemStack -> {
        if (itemStack.hasItemMeta()) {
            ItemMeta itemMeta = itemStack.getItemMeta();
            if (itemMeta.hasEnchants()) {
                return Stream.of(Enchantment.values()).filter(itemMeta::hasEnchant).filter(itemMeta::hasConflictingEnchant).anyMatch(enchant -> itemMeta.getEnchantLevel(enchant) > enchant.getMaxLevel());
            }
        }

        return false;
    };
    private final Predicate<ItemStack> bannedItemCheck = itemStack -> blockedItems.contains(itemStack.getType());
    private final Predicate<ItemStack> durabilityCheck = itemStack -> {
        if (itemStack.hasItemMeta()) {
            return ((Damageable) itemStack.getItemMeta()).getDamage() <= 0;
        }

        return false;
    };
    private final Predicate<ItemStack> fireworkCheck = itemStack -> {
        if (itemStack.getType() == Material.FIREWORK_ROCKET && itemStack.hasItemMeta()) {
            return ((FireworkMeta) itemStack.getItemMeta()).getEffectsSize() > 5;
        }

        return false;
    };
    private final Predicate<ItemStack> attributeCheck = itemStack -> getTag(itemStack).containsKey("AttributeModifiers");
    private final List<String> bannedJsonTextComponentKeys = Arrays.asList("translate", "with", "score", "selector", "keybind", "color", "bold", "italic", "underlined", "strikethrough", "obfuscated", "insertion", "clickEvent", "hoverEvent");
    private final Predicate<ItemStack> bookCheck = itemStack -> {
        NbtCompound tag = getTag(itemStack);
        if (tag.containsKey("pages")) {
            NbtList<String> pages = tag.getList("pages");
            if (pages.size() > 0) {
                return pages.asCollection().stream().map(page -> new Gson().fromJson(page.getValue(), JsonObject.class)).filter(JsonElement::isJsonObject).map(JsonElement::getAsJsonObject).anyMatch(json -> bannedJsonTextComponentKeys.stream().anyMatch(json::has));
            }
        }

        return false;
    };
    private final Predicate<ItemStack> loreCheck = itemStack -> itemStack.hasItemMeta() && itemStack.getItemMeta().hasLore();
    private final Predicate<ItemStack> itemNameCheck = itemStack -> {
        if (itemStack.hasItemMeta()) {
            ItemMeta itemMeta = itemStack.getItemMeta();
            if (itemMeta.hasDisplayName()) {
                NbtCompound tag = getTag(itemStack);
                if (tag.containsKey("display")) {
                    NbtCompound display = tag.getCompound("display");
                    if (display.containsKey("name")) {
                        return StreamSupport.stream(new Gson().fromJson(display.getString("name"), JsonArray.class).spliterator(), false).filter(JsonElement::isJsonObject).map(JsonElement::getAsJsonObject).anyMatch(json -> bannedJsonTextComponentKeys.stream().anyMatch(json::has));
                    }
                }
            }
        }

        return false;
    };
    public final Predicate<ItemStack> shulkerCheck = itemStack -> {
        if (itemStack == null) return false;
        switch (itemStack.getType()) {
            case BLACK_SHULKER_BOX:
            case BLUE_SHULKER_BOX:
            case BROWN_SHULKER_BOX:
            case CYAN_SHULKER_BOX:
            case GRAY_SHULKER_BOX:
            case GREEN_SHULKER_BOX:
            case LIGHT_BLUE_SHULKER_BOX:
            case LIME_SHULKER_BOX:
            case MAGENTA_SHULKER_BOX:
            case ORANGE_SHULKER_BOX:
            case PINK_SHULKER_BOX:
            case LIGHT_GRAY_SHULKER_BOX:
            case PURPLE_SHULKER_BOX:
            case RED_SHULKER_BOX:
            case WHITE_SHULKER_BOX:
            case YELLOW_SHULKER_BOX: {
                if (itemStack.getAmount() > 1) return true;
                if (!itemStack.hasItemMeta()) return false;
                BlockStateMeta meta = (BlockStateMeta) itemStack.getItemMeta();
                ShulkerBox box = (ShulkerBox) meta.getBlockState();
                Inventory inv = box.getSnapshotInventory();
                for (ItemStack i : inv.getContents()) {
                    if (ItemExploitHandler.this.shulkerCheck.test(i)) {
                        return true;
                    }
                }
            }
        }
        return false;
    };
    private final Predicate<ItemStack> creativeMenuCheck = itemStack -> {
        if (itemStack.getType().equals(Material.NETHER_STAR) && itemStack.hasItemMeta()) {
            ItemMeta itemMeta = itemStack.getItemMeta();
            return !(itemMeta.hasDisplayName() && itemMeta.getDisplayName().contains("Creative Menu"));
        }
        return false;
    };
    private final List<CaughtUserData> users = new ArrayList<>();
    private final List<UUID> antiWarningSpam = new ArrayList<>();

    public ItemExploitHandler() {
        Logger logger = Creative.getInstance().getLogger();
        try {
            loadBlockedItems();
        } catch (IOException e) {
            logger.warning("An error occurred while trying to create/read banned_items.yml");
        }

        try {
//        Core.runTask(() -> {
//            try {
            loadCaughtItems();
//            } catch (IOException e) {
//                logger.warning("An error occurred while trying to create/read caught_items.yml");
//            }
//        });
        } catch (IOException e) {
            logger.warning("An error occurred while trying to create/read caught_items.yml");
        }
    }

    private Optional<String> getTexture(ItemStack itemStack) {
        NbtCompound tag = getTag(itemStack);
        if (!tag.containsKey("SkullOwner")) {
            return Optional.empty();
        }

        NbtCompound skullOwner = tag.getCompound("SkullOwner");
        if (!skullOwner.containsKey("Properties")) {
            return Optional.empty();
        }

        NbtCompound properties = skullOwner.getCompound("Properties");
        if (!properties.containsKey("textures")) {
            return Optional.empty();
        }

        List<NbtCompound> textures = properties.getList("textures").asCollection().stream().filter(NbtCompound.class::isInstance).map(NbtCompound.class::cast).collect(Collectors.toList());
        if (textures.isEmpty()) {
            return Optional.empty();
        }

        NbtCompound value = textures.get(0);
        return Optional.ofNullable(value.getString("Value"));
    }

    public Optional<CaughtUserData> getData(UUID uuid) {
        return users.stream().filter(data -> data.getUuid().equals(uuid)).findFirst();
    }

    private void loadCaughtItems() throws IOException {
        users.clear();
        File caughtItemsFile = new File(Creative.getInstance().getDataFolder(), "caught_items.yml");
        if (!caughtItemsFile.exists()) {
            caughtItemsFile.getParentFile().mkdirs();
            caughtItemsFile.createNewFile();
        }

        YamlConfiguration yml = YamlConfiguration.loadConfiguration(caughtItemsFile);
        yml.getKeys(false).forEach(key -> {
            UUID uuid = UUID.fromString(key);
            List<CaughtItemData> itemData = new ArrayList<>();
            yml.getMapList(key).forEach(bannedItem -> {
                YamlConfiguration temp = new YamlConfiguration();
                bannedItem.forEach((k, v) -> temp.set(k.toString(), v));
                boolean handled = temp.getBoolean("handled");
                ItemStack item = temp.getItemStack("item");
                long timestamp = temp.getLong("time");
                List<String> list = parseLore(handled, item);
                boolean notName = false;
//                StringBuilder str = new StringBuilder();
                for (int i = 4; i < list.size(); i++) {
                    String s = list.get(i);
//                    str.append(s).append(",");
                    if (!s.equals(ChatColor.GREEN + "- Custom Item Name Not Plain Text") &&
                            !s.equals(ChatColor.GREEN + "- Non-Head Shop Head") &&
                            !s.equals(ChatColor.GREEN + "- Armor/Tool/Weapon Damage/Durability Not 0")) {
                        notName = true;
                        break;
                    }
                }
                if (notName) {
                    itemData.add(new CaughtItemData(handled, item, timestamp));
//                    Core.logMessage("ItemDebug", str.toString());
                }
            });
            if (!itemData.isEmpty()) {
                CaughtUserData userData = new CaughtUserData(itemData, uuid);
                users.add(userData);
            }
        });
        users.sort((caughtUserData, t1) -> (int) (t1.getData().stream().filter(i -> !i.isHandled()).count() - caughtUserData.getData().stream().filter(i -> !i.isHandled()).count()));
    }

    public void saveCaughtItems() {
        YamlConfiguration yml = new YamlConfiguration();
        users.forEach(data -> yml.set(data.getUuid().toString(), data.getData().stream().map(cid -> {
            YamlConfiguration item = new YamlConfiguration();
            item.set("handled", cid.isHandled());
            item.set("item", cid.getItem());
            item.set("time", cid.getTimestamp());
            return item;
        }).collect(Collectors.toList())));

        try {
            File bannedItemsFile = new File(Creative.getInstance().getDataFolder(), "caught_items.yml");
            if (!bannedItemsFile.exists()) {
                bannedItemsFile.getParentFile().mkdirs();
                bannedItemsFile.createNewFile();
            }

            yml.save(bannedItemsFile);
        } catch (IOException e) {
            Creative.getInstance().getLogger().warning("An error occurred while trying to save caught_items.yml");
        }
    }

    public void loadBlockedItems() throws IOException {
        blockedItems.clear();
        File bannedItemsFile = new File(Creative.getInstance().getDataFolder(), "banned_items.yml");
        if (!bannedItemsFile.exists()) {
            bannedItemsFile.getParentFile().mkdirs();
            bannedItemsFile.createNewFile();
        }

        Logger logger = Creative.getInstance().getLogger();
        YamlConfiguration yml = YamlConfiguration.loadConfiguration(bannedItemsFile);
        yml.getStringList("items").forEach(s -> {
            Material material = Material.matchMaterial(s);
            if (material == null) {
                logger.warning("Material ID of " + s + " does not exist.");
            }

            blockedItems.add(material);
        });
    }

    private void handle(Player player, List<ItemStack> items, Runnable action) {
        List<ItemStack> caughtItems = items.stream().filter(Objects::nonNull).filter(itemStack -> {
            if (airCheck.test(itemStack)) {
                return false;
            }
            if (creativeMenuCheck.test(itemStack)) {
                return false;
            }
            if (enchantmentCheck.test(itemStack)) {
                return true;
            }
//            if (durabilityCheck.test(itemStack)) {
//                return true;
//            }
            if (attributeCheck.test(itemStack)) {
                return true;
            }
            if (bookCheck.test(itemStack)) {
                return true;
            }
            if (loreCheck.test(itemStack)) {
                return true;
            }
            if (bannedItemCheck.test(itemStack)) {
                return true;
            }
//            if (headCheck.test(itemStack)) {
//                return true;
//            }
            if (potionCheck.test(itemStack)) {
                return true;
            }
//            if (itemNameCheck.test(itemStack)) {
//                return true;
//            }
            if (shulkerCheck.test(itemStack)) {
                return true;
            }
            return fireworkCheck.test(itemStack);
        }).collect(Collectors.toList());
        if (caughtItems.isEmpty()) {
            return;
        }

        action.run();
        player.updateInventory();
        Optional<CaughtUserData> dataOptional = this.users.stream().filter(data -> data.getUuid().equals(player.getUniqueId())).findFirst();
        if (dataOptional.isPresent()) {
            caughtItems.forEach(itemStack -> dataOptional.get().caughtItem(itemStack));
        } else {
            this.users.add(new CaughtUserData(caughtItems.stream().map(item -> new CaughtItemData(false, item, System.currentTimeMillis())).collect(Collectors.toList()), player.getUniqueId()));
        }

        if (antiWarningSpam.contains(player.getUniqueId())) {
            return;
        }

        Core.getPlayerManager().getOnlinePlayers().stream().filter(cPlayer -> cPlayer.getRank().getRankId() >= Rank.COORDINATOR.getRankId()).map(CPlayer::getBukkitPlayer).forEach(staff -> {
            antiWarningSpam.add(player.getUniqueId());
            Bukkit.getScheduler().runTaskLater(Creative.getInstance(), () -> antiWarningSpam.remove(player.getUniqueId()), 100);
            staff.sendMessage(ChatColor.AQUA + player.getName() + ChatColor.RED + " attempted to spawn/use a hacked/prohibited item!");
        });
    }

    @EventHandler
    public void onJoin(PlayerJoinEvent event) {
        Core.runTask(Creative.getInstance(), () -> {
            Player player = event.getPlayer();
            CPlayer cPlayer = Core.getPlayerManager().getPlayer(player);
            if (cPlayer == null || cPlayer.getRank().getRankId() < Rank.COORDINATOR.getRankId()) return;

            if (users.stream().map(CaughtUserData::getData).flatMap(List::stream).anyMatch(itemData -> !itemData.isHandled())) {
                new FormattedMessage("There are pending banned/hacked item cases. View these items by running /bic, or clicking this message.")
                        .color(ChatColor.GREEN).tooltip(ChatColor.GREEN + "Run " + ChatColor.YELLOW + "/bic").command("/bic").send(cPlayer);
            }
        });
    }

    @EventHandler
    public void onItemUse(PlayerInteractEvent event) {
        Player player = event.getPlayer();
        CPlayer cPlayer = Core.getPlayerManager().getPlayer(player);
        if (cPlayer == null || cPlayer.getRank().getRankId() >= Rank.TRAINEE.getRankId()) {
            return;
        }

        PlayerInventory inventory = player.getInventory();
        handle(player, Arrays.asList(inventory.getItemInMainHand(), inventory.getItemInOffHand()), () -> {
            inventory.setItemInMainHand(null);
            inventory.setItemInOffHand(null);
        });
    }

    @EventHandler
    public void onItemDrop(PlayerDropItemEvent event) {
        Player player = event.getPlayer();
        CPlayer cPlayer = Core.getPlayerManager().getPlayer(player);
        if (cPlayer == null || cPlayer.getRank().getRankId() >= Rank.TRAINEE.getRankId()) {
            return;
        }

        Item itemEntity = event.getItemDrop();
        handle(player, Collections.singletonList(itemEntity.getItemStack()), itemEntity::remove);
    }

    @EventHandler
    public void onItemPickup(EntityPickupItemEvent event) {
        if (event.getEntity().getType() != EntityType.PLAYER) {
            return;
        }

        Player player = (Player) event.getEntity();
        CPlayer cPlayer = Core.getPlayerManager().getPlayer(player);
        if (cPlayer == null || cPlayer.getRank().getRankId() >= Rank.TRAINEE.getRankId()) {
            return;
        }

        Item itemEntity = event.getItem();
        handle(player, Collections.singletonList(itemEntity.getItemStack()), () -> {
            Bukkit.getScheduler().scheduleSyncDelayedTask(Creative.getInstance(), itemEntity::remove);
            event.setCancelled(true);
        });
    }

    //PlotSquared error occurs w/o this
    @EventHandler(priority = EventPriority.HIGHEST)
    public void onCreativeInventoryClick(InventoryCreativeEvent event) {
        Player player = (Player) event.getWhoClicked();
        CPlayer cPlayer = Core.getPlayerManager().getPlayer(player);
        if (cPlayer == null || cPlayer.getRank().getRankId() >= Rank.TRAINEE.getRankId()) {
            return;
        }

        handle(player, Arrays.asList(event.getCurrentItem(), event.getCursor()), () -> {
            event.setCurrentItem(null);
            event.setCursor(null);
        });
    }

    private NbtCompound getTag(ItemStack itemStack) {
        return NbtFactory.fromNMSCompound(NbtFactory.fromItemTag(MinecraftReflection.getBukkitItemStack(itemStack)).getHandle());
    }

    public void viewPlayer(CPlayer player, CaughtUserData userData, OfflinePlayer offlinePlayer, int page) {
        List<MenuButton> buttons = new ArrayList<>();
        List<CaughtItemData> caughtItems = userData.getData();
        for (int x = 0; x < 45; x++) {
            try {
                CaughtItemData itemData = caughtItems.get(x + (page - 1) * 45);
                ItemStack itemStack = itemData.getItem();
                buttons.add(new MenuButton(x, parseItem(itemStack, itemData), ImmutableMap.of(ClickType.LEFT, p -> {
                    p.getInventory().addItem(itemStack);
                    p.closeInventory();
                }, ClickType.RIGHT, p -> manageItem(p, userData, itemData, offlinePlayer))));
            } catch (IndexOutOfBoundsException ignored) {
            }
        }

        MenuUtil menuUtil = Creative.getInstance().getMenuUtil();
        if (page - 1 > 0) {
            buttons.add(new MenuButton(45, menuUtil.last, ImmutableMap.of(ClickType.LEFT, p -> viewPlayer(p, userData, offlinePlayer, page - 1))));
        }

        buttons.add(new MenuButton(49, menuUtil.back, ImmutableMap.of(ClickType.LEFT, p -> openPlayerMenu(p, 0))));
        if (page <= (int) Math.ceil(caughtItems.size() / 45D)) {
            buttons.add(new MenuButton(53, menuUtil.next, ImmutableMap.of(ClickType.LEFT, p -> viewPlayer(p, userData, offlinePlayer, page + 1))));
        }

        new Menu(54, ChatColor.RED + offlinePlayer.getName() + "'s Caught Items", player, buttons).open();
    }

    private void manageItem(CPlayer player, CaughtUserData userData, CaughtItemData itemData, OfflinePlayer offlinePlayer) {
        String reason = " Possession of banned/hacked items and/or hacked/modded client.";
        List<MenuButton> buttons = new ArrayList<>();
        buttons.add(new MenuButton(0, ItemUtil.create(Material.CLOCK, ChatColor.GREEN + "Caught at " + new SimpleDateFormat("MM/dd/yyyy HH:mm:ss").format(new Date(itemData.getTimestamp()))), ImmutableMap.of()));
        buttons.add(new MenuButton(1, ItemUtil.create(Material.BARRIER, ChatColor.RED + "Delete", Arrays.asList(ChatColor.GOLD + "If this was incorrectly caught,", ChatColor.GOLD + "report in #reporting-chat.")), ImmutableMap.of(ClickType.LEFT, p -> {
            userData.getData().remove(itemData);
            viewPlayer(p, userData, offlinePlayer, 1);
        })));
        buttons.add(new MenuButton(2, ItemUtil.create(Material.EMERALD, ChatColor.GREEN + "Status: " + ChatColor.YELLOW + (itemData.isHandled() ? "Complete" : "Pending")), ImmutableMap.of(ClickType.LEFT, p -> {
            itemData.setHandled(!itemData.isHandled());
            viewPlayer(player, userData, offlinePlayer, 1);
        })));
        buttons.add(new MenuButton(8, Creative.getInstance().getMenuUtil().back, ImmutableMap.of(ClickType.LEFT, p -> viewPlayer(p, userData, offlinePlayer, 1))));
        new Menu(9, ChatColor.RED + "Manage This Item", player, buttons).open();
    }

    private List<String> parseLore(boolean handled, ItemStack itemStack) {
        if (itemStack == null) return new ArrayList<>();
        List<String> lore = new ArrayList<>();
        lore.add(ChatColor.GREEN + "LEFT-CLICK " + ChatColor.YELLOW + " to spawn this item for closer inspection.");
        lore.add(ChatColor.GREEN + "RIGHT-CLICK " + ChatColor.YELLOW + " to manage this item.");
        lore.add(ChatColor.LIGHT_PURPLE + "Status: " + (handled ? "Complete" : "Pending"));
        lore.add(ChatColor.GREEN + "Violations:");
        if (bannedItemCheck.test(itemStack)) {
            lore.add(ChatColor.GREEN + "- Banned Block/Item");
        }
        if (headCheck.test(itemStack)) {
            lore.add(ChatColor.GREEN + "- Non-Head Shop Head");
        }
        if (potionCheck.test(itemStack)) {
            lore.add(ChatColor.GREEN + "- Custom Potion Effects");
        }
        if (enchantmentCheck.test(itemStack)) {
            lore.add(ChatColor.GREEN + "- Invalid Enchantments");
        }
        if (durabilityCheck.test(itemStack)) {
            lore.add(ChatColor.GREEN + "- Armor/Tool/Weapon Damage/Durability Not 0");
        }
        if (fireworkCheck.test(itemStack)) {
            lore.add(ChatColor.GREEN + "- Too Many Firework Effects");
        }
        if (attributeCheck.test(itemStack)) {
            lore.add(ChatColor.GREEN + "- Contains Attribute Modifiers");
        }
        if (bookCheck.test(itemStack)) {
            lore.add(ChatColor.GREEN + "- Book Contents Not Plain Text");
        }
        if (loreCheck.test(itemStack)) {
            lore.add(ChatColor.GREEN + "- Contains Lore");
        }
        if (itemNameCheck.test(itemStack)) {
            lore.add(ChatColor.GREEN + "- Custom Item Name Not Plain Text");
        }
        if (shulkerCheck.test(itemStack)) {
            lore.add(ChatColor.GREEN + "- Illegal Shulker Box Size");
            itemStack.setAmount(1);
            if (itemStack.hasItemMeta()) {
                BlockStateMeta meta = (BlockStateMeta) itemStack.getItemMeta();
                ShulkerBox box = (ShulkerBox) meta.getBlockState();
                box.getInventory().clear();
                box.update();
                meta.setBlockState(box);
                itemStack.setItemMeta(meta);
            }
        }

        return lore;
    }

    private ItemStack parseItem(ItemStack caughtItem, CaughtItemData itemData) {
        ItemStack itemStack = caughtItem.clone();
        ItemMeta itemMeta = itemStack.getItemMeta();
        itemMeta.setDisplayName(ChatColor.GREEN + "Caught at " + new SimpleDateFormat("MM/dd/yyyy HH:mm:ss").format(new Date(itemData.getTimestamp())));
        itemMeta.setLore(parseLore(itemData.isHandled(), caughtItem));
        itemStack.setItemMeta(itemMeta);
        return itemStack;
    }

    public void openPlayerMenu(CPlayer player, int page) {
        if (page * 45 >= users.size()) return;

        List<MenuButton> buttons = new ArrayList<>();
        List<CaughtUserData> userList = users.subList(page * 45, Math.min((page + 1) * 45, users.size()));

        int slot = 0;
        List<String> lore = Arrays.asList(ChatColor.GRAY + "Click to view the banned items",
                ChatColor.GRAY + "this player has been caught with");
        for (CaughtUserData data : userList) {
            OfflinePlayer offlinePlayer = Bukkit.getOfflinePlayer(data.getUuid());
            if (offlinePlayer.getName() == null) continue;
            buttons.add(new MenuButton(slot++, ItemUtil.create(Material.PLAYER_HEAD, 1, 3,
                    ChatColor.YELLOW + offlinePlayer.getName(),
                    Arrays.asList(ChatColor.GRAY + "", ChatColor.GRAY + "Caught items: " + ChatColor.YELLOW + data.getData().size(),
                            ChatColor.GRAY + "Unresolved items: " + ChatColor.YELLOW + data.getData().stream().filter(i -> !i.isHandled()).count(),
                            ChatColor.GRAY + "Resolved items: " + ChatColor.YELLOW + data.getData().stream().filter(CaughtItemData::isHandled).count())),
                    ImmutableMap.of(ClickType.LEFT, p -> viewPlayer(p, data, offlinePlayer, 1))));
        }

        if (page >= 1) {
            buttons.add(new MenuButton(45, ItemUtil.create(Material.ARROW, ChatColor.GREEN + "Previous Page"),
                    ImmutableMap.of(ClickType.LEFT, p -> openPlayerMenu(p, page - 1))));
        }
        if (users.size() >= ((page + 1) * 45)) {
            buttons.add(new MenuButton(53, ItemUtil.create(Material.ARROW, ChatColor.GREEN + "Next Page"),
                    ImmutableMap.of(ClickType.LEFT, p -> openPlayerMenu(p, page + 1))));
        }

        new Menu(54, ChatColor.BLUE + "Banned Items", player, buttons).open();
    }
}
